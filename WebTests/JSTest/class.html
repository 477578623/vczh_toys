<!DOCTYPE html>
<html>
<head>
    <title>Class</title>
    <script>
        function __MemberBase() {
        }
        Object.defineProperty(__MemberBase, "NORMAL", {
            configurable: false,
            enumerable: true,
            writable: false,
            value: 1,
        });
        Object.defineProperty(__MemberBase, "VIRTUAL", {
            configurable: false,
            enumerable: true,
            writable: false,
            value: 2,
        });
        Object.defineProperty(__MemberBase, "OVERRIDE", {
            configurable: false,
            enumerable: true,
            writable: false,
            value: 3,
        });
        Object.defineProperty(__MemberBase.prototype, "DeclaringType", {
            configurable: false,
            enumerable: true,
            writable: true,
            value: null,
        });
        Object.defineProperty(__MemberBase.prototype, "Virtual", {
            configurable: false,
            enumerable: true,
            writable: true,
            value: __MemberBase.NORMAL,
        });
        Object.defineProperty(__MemberBase.prototype, "New", {
            configurable: false,
            enumerable: true,
            writable: true,
            value: false,
        });

        function __PrivateMember(value) {
            this.value = value;
        }
        __PrivateMember.prototype.__proto__ = __MemberBase.prototype;

        function __ProtectedMember(value) {
            this.value = value;
        }
        __ProtectedMember.prototype.__proto__ = __MemberBase.prototype;

        function __PublicMember(value) {
            this.value = value;
        }
        __PublicMember.prototype.__proto__ = __MemberBase.prototype;

        function __BuildOverloadingFunctions() {
            if (arguments.length % 2 != 0) {
                throw new Error("Arguments for Overload should be typeList1, func1, typeList2, func2, ...");
            }

            var functionCount = Math.floor(arguments.length / 2);
            var typeLists = new Array(functionCount);
            var funcs = new Array(functionCount);
            for (var i = 0; i < functionCount; i++) {
                typeLists[i] = arguments[i * 2];
                funcs[i] = arguments[i * 2 + 1];
            }

            return function () {
                for (var i in typeLists) {
                    var typeList = typeLists[i];
                    if (arguments.length != typeList.length) continue;

                    var matched = true;
                    for (var j in typeList) {
                        if (!matched) break;
                        var arg = arguments[j];

                        var type = typeList[j];
                        if (type == Number) {
                            matched = typeof (arg) == "number";
                        }
                        else if (type == Boolean) {
                            matched = typeof (arg) == "boolean";
                        }
                        else if (type == String) {
                            matched = typeof (arg) == "string";
                        }
                        else if (type == Array) {
                            matched = arg instanceof Array;
                        }
                        else if (type == Function) {
                            matched = typeof (arg) == "function";
                        }
                        else if (type == Object) {
                            matched = typeof (arg) == "object";
                        }
                        else if (arg == undefined) {
                            matched = false;
                        }
                        else if (arg != null) {
                            if (type.prototype.__proto__ == Class) {
                                if (arg instanceof Class) {
                                    matched = type.IsAssignableFrom(arg.GetType());
                                }
                                else {
                                    matched = false;
                                }
                            }
                            else {
                                matched = arg instanceof type;
                            }
                        }
                    }

                    if (matched) {
                        return funcs[i].apply(this, arguments);
                    }
                }
                throw new Error("Cannot find a overloading function that matches the arguments.");
            }
        }

        function __DefineDecorator(accessor, name, decorator) {
            Object.defineProperty(accessor, name, {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function (value) {
                    var member = accessor(value);
                    decorator(member, value);
                    return member;
                }
            });
        }

        function __DefineSubDecorator(accessor, name, decorator) {
            Object.defineProperty(accessor, name, {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return accessor(decorator.apply(null, arguments));
                }
            });
        }

        function __DefineOverload(accessor) {
            __DefineSubDecorator(accessor, "Overload", __BuildOverloadingFunctions);
        }

        function __DefineNew(accessor) {
            __DefineDecorator(accessor, "New", function (member) {
                member.New = true;
            });
        }

        function __DefineVirtual(accessor) {
            __DefineDecorator(accessor, "Virtual", function (member) {
                member.Virtual = __MemberBase.VIRTUAL;
            });
        }

        function __DefineNewVirtual(accessor) {
            __DefineDecorator(accessor, "NewVirtual", function (member) {
                member.New = true;
                member.Virtual = __MemberBase.VIRTUAL;
            });
        }

        function __DefineOverride(accessor) {
            __DefineDecorator(accessor, "Override", function (member) {
                member.Virtual = __MemberBase.OVERRIDE;
            });
        }

        function __DefineAbstract(accessor) {
            __DefineDecorator(accessor, "Abstract", function (member) {
                member.Virtual = __MemberBase.VIRTUAL;
                member.value = function () {
                    throw new Error("Cannot call an abstract function.");
                }
            });
        }

        function Private(value) {
            return new __PrivateMember(value);
        }
        __DefineOverload(Private);

        function Protected(value) {
            return new __ProtectedMember(value);
        }
        __DefineOverload(Protected);
        __DefineNew(Protected);
        __DefineVirtual(Protected);
        __DefineNewVirtual(Protected);
        __DefineAbstract(Protected);
        __DefineOverride(Protected);

        function Public(value) {
            return new __PublicMember(value);
        }
        __DefineOverload(Public);
        __DefineNew(Public);
        __DefineVirtual(Public);
        __DefineNewVirtual(Public);
        __DefineAbstract(Public);
        __DefineOverride(Public);

        function Class(fullName) {

            function CreateInternalReference(description) {
                // create an internal reference from a type description and copy all members
                var internalReference = {};

                for (var name in description) {
                    var member = description[name];

                    if (member instanceof __PrivateMember) {
                        internalReference[name] = member.value;
                    }
                    else if (member instanceof __ProtectedMember) {
                        internalReference[name] = member.value;
                    }
                    else if (member instanceof __PublicMember) {
                        internalReference[name] = member.value;
                    }
                }

                return internalReference;
            }

            function CopyReferencableMember(target, source, memberName, memberValue, forceReplace) {
                // copy a closured member from one internal reference to another
                if (target.hasOwnProperty(memberName)) {
                    if (!forceReplace) {
                        return;
                    }
                }

                if (typeof memberValue == "function") {
                    Object.defineProperty(target, memberName, {
                        configurable: false,
                        enumerable: true,
                        writable: false,
                        value: function () {
                            return memberValue.apply(source, arguments);
                        }
                    });
                }
                else {
                    Object.defineProperty(target, memberName, {
                        configurable: false,
                        enumerable: true,
                        get: function () {
                            return source[memberName];
                        },
                        set: function (value) {
                            source[memberName] = value;
                        }
                    });
                }
            }

            function CopyReferencableMembers(target, source, description, forInternalReference) {
                // copy all closured members from one internal reference to another
                for (var name in description) {
                    if (name != "__Constructor") {
                        (function () {
                            var memberName = name;
                            var member = description[memberName];

                            if (member instanceof __ProtectedMember) {
                                if (forInternalReference) {
                                    CopyReferencableMember(target, source, memberName, member.value, false);
                                }
                            }
                            else if (member instanceof __PublicMember) {
                                CopyReferencableMember(target, source, memberName, member.value, false);
                            }
                        })();
                    }
                }
            }

            function OverrideVirtualFunction(source, memberName, memberValue, targetTypes, accumulatedBaseClasses, accumulatedBaseReferences) {
                // override a virtual functions in base internal references
                for (var i in targetTypes) {
                    var targetType = targetTypes[i];
                    var target = accumulatedBaseReferences[accumulatedBaseClasses.indexOf(targetType)];
                    var targetDescription = targetType.Description;
                    var targetMember = targetDescription[memberName];
                    if (targetMember != undefined) {
                        if (targetMember.Virtual == __MemberBase.VIRTUAL) {
                            CopyReferencableMember(target, source, memberName, memberValue, true);
                        }
                        if (targetMember.New == true) {
                            continue;
                        }
                    }
                    OverrideVirtualFunction(source, memberName, memberValue, targetType.BaseClasses, accumulatedBaseClasses, accumulatedBaseReferences);
                }
            }

            function OverrideVirtualFunctions(source, sourceType, accumulatedBaseClasses, accumulatedBaseReferences) {
                // override every virtual functions in base internal references
                var description = sourceType.Description;
                for (var name in description) {
                    var member = description[name];
                    if (member.Virtual == __MemberBase.OVERRIDE) {
                        OverrideVirtualFunction(source, name, source[name], sourceType.BaseClasses, accumulatedBaseClasses, accumulatedBaseReferences);
                    }
                }
            }

            function CreateCompleteInternalReference(type, accumulatedBaseClasses, accumulatedBaseReferences) {
                // create an internal reference from a type with inherited members
                var description = type.Description;
                var baseClasses = type.BaseClasses;
                var baseInstances = new Array(baseClasses.length);

                for (var i = 0; i <= baseClasses.length; i++) {
                    if (i == baseClasses.length) {
                        // create the internal reference for the current type
                        var internalReference = CreateInternalReference(description);

                        // override virtual functions in base internal references
                        OverrideVirtualFunctions(internalReference, type, baseClasses, baseInstances);

                        // inherit members from base classes
                        for (var j = 0; j < accumulatedBaseClasses.length; j++) {
                            CopyReferencableMembers(
                                internalReference,
                                accumulatedBaseReferences[j],
                                accumulatedBaseClasses[j].Description,
                                true);
                        }

                        accumulatedBaseClasses.push(type);
                        accumulatedBaseReferences.push(internalReference);

                        // implement __GetBase
                        internalReference.__GetBase = function (baseType) {
                            for (var k in baseClasses) {
                                if (baseClasses[k] == baseType) {
                                    return baseInstances[k];
                                }
                            }
                            return undefined;
                        }

                        return internalReference;
                    }
                    else {
                        // create a complete internal reference for a base class
                        var baseInstance = CreateCompleteInternalReference(
                            baseClasses[i],
                            accumulatedBaseClasses,
                            accumulatedBaseReferences);
                        baseInstances[i] = baseInstance;
                    }
                }
            }

            function InjectInternalReference(internalReference, typeObject, externalReference) {
                // implement __GetType and __GetExternalReference
                internalReference.__GetType = function () {
                    return typeObject;
                }

                internalReference.__GetExternalReference = function () {
                    return externalReference;
                }
            }

            var directBaseClasses = new Array(arguments.length - 2);
            for (var i = 1; i < arguments.length - 1; i++) {
                directBaseClasses[i - 1] = arguments[i];
            }
            var description = arguments[arguments.length - 1];

            function Type() {
                var typeObject = arguments.callee;

                // create every internalReference, which is the value of "this" in member functions
                var accumulatedBaseClasses = [];
                var accumulatedBaseReferences = [];
                var internalReference = CreateCompleteInternalReference(
                    typeObject,
                    accumulatedBaseClasses,
                    accumulatedBaseReferences);

                // create the externalReference
                var externalReference = {};

                // inject externalReference.GetType()
                Object.defineProperty(externalReference, "__GetType", {
                    configurable: false,
                    enumerable: true,
                    writable: false,
                    value: function () {
                        return typeObject;
                    }
                });

                // inject internalReference.__GetType()
                // inject internalReference.__GetExternalReference()
                for (var i in accumulatedBaseReferences) {
                    InjectInternalReference(accumulatedBaseReferences[i], typeObject, externalReference);
                }

                // copy all public member fields to externalReference
                for (var i in accumulatedBaseReferences) {
                    CopyReferencableMembers(
                        externalReference,
                        accumulatedBaseReferences[i],
                        accumulatedBaseClasses[i].Description,
                        false);
                }

                // return the externalReference
                externalReference.__proto__ = typeObject.prototype;
                if (internalReference.hasOwnProperty("__Constructor")) {
                    internalReference.__Constructor.apply(internalReference, arguments);
                }
                return externalReference;
            }

            for (var name in description) {
                description[name].DeclaringType = Type;
            }

            var flattenedBaseClasses = [];
            function AddFlattenedBaseClass(type) {
                if (flattenedBaseClasses.indexOf(type) == -1) {
                    flattenedBaseClasses.push(type);
                }
                else {
                    throw new Error("Cannot non-virtually inherit from a type multiple times.");
                }
            }

            for (var i in directBaseClasses) {
                var baseClass = directBaseClasses[i];
                var baseFlattened = baseClass.FlattenedBaseClasses;
                for (var j in baseFlattened) {
                    AddFlattenedBaseClass(baseFlattened[j]);
                }
                AddFlattenedBaseClass(baseClass);
            }

            var flattenedDescription = {};
            function AddFlattenedMember(name, member) {

                if (member.Virtual == __MemberBase.OVERRIDE) {
                    return;
                }

                if (member.DeclaringType != Type) {
                    if (name == "__Constructor") {
                        return;
                    }

                    if (member instanceof __PrivateMember) {
                        return;
                    }

                    if (flattenedDescription.hasOwnProperty(name)) {
                        if (!description.hasOwnProperty(name)) {
                            throw new Error("Cannot inherit multiple members of the same name \"" + name + "\" without defining a new one.");
                        }
                    }
                }

                flattenedDescription[name] = member;
            }

            for (var i in directBaseClasses) {
                var baseClass = directBaseClasses[i];
                var flattened = baseClass.FlattenedDescription;
                for (var j in flattened) {
                    AddFlattenedMember(j, flattened[j]);
                }
            }
            for (var j in description) {
                AddFlattenedMember(j, description[j]);
            }

            Object.defineProperty(Type, "FullName", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: fullName,
            });

            Object.defineProperty(Type, "Description", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: description,
            });

            Object.defineProperty(Type, "FlattenedDescription", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: flattenedDescription,
            });

            Object.defineProperty(Type, "BaseClasses", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: directBaseClasses,
            });

            Object.defineProperty(Type, "FlattenedBaseClasses", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: flattenedBaseClasses,
            });

            Object.defineProperty(Type, "IsAssignableFrom", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function (type) {
                    if (type == Type) {
                        return true;
                    }
                    else {
                        var baseClasses = type.BaseClasses;
                        for (var i in baseClasses) {
                            if (Type.IsAssignableFrom(baseClasses[i])) {
                                return true;
                            }
                        }
                        return false;
                    }
                }
            });

            Type.prototype.__proto__ = Class.prototype;
            return Type;
        }

        /*
        API:
            this.__GetType()                            // Get the real type that creates this object.
            this.__GetBase(type)                        // Get the internal reference of a base type.
            this.__GetExternalReference()               // Get the external reference of this instance, for passing the value of "this" out of the class.

            Type.Name                                   // Get the full name
            Type.Description                            // Get all declared members in this type
            Type.FlattenedDescription                   // Get all potentially visible members in this type
            Type.BaseClasses                            // Get all direct base classes of this type
            Type.FlattenedBaseClasses                   // Get all direct or indirect base classes of this type
            Type.IsAssignableFrom(type)                 // Returns true if "type" is or inherits from "Type"

            Class(fullName, type1, type2, ... {
                Member: (Public|Protected|Private) (value | function),
                Member: (Public|Protected|Private).Overload(typeList1, function1, typeList2, function2, ...);
                Member: (Public|Protected).(New|Virtual|NewVirtual|Override) (function),
                Member: (Public|Protected).Abstract();
                Member: Public.Event();
                Member: Public.Property({
                    readonly: true | false,             // (optional, false)
                    hasEvent: true | false,             // (optional, false)
                    getterName: "GetterNameToOverride", // (optional, "GetMember")
                    setterName: "SetterNameToOverride", // (optional, "SetMember")      implies readonly: false
                    eventName: "EventNameToOverride",   // (optional, "MemberChanged")  implies hasEvent: true
                }),
            });
        */
    </script>
</head>
<body style="font-family: 'Segoe UI'; font-size: 14px;">
    <script>
        function assert(code) {
            if (!code) throw new Error("Fuck");
        }

        var __passedCases = 0;
        var __failedCases = 0;
        var __emptyCases = 0;

        function testCase(name, code) {
            console.debug("Running: " + name);

            var div = document.createElement("div");
            div.appendChild(document.createTextNode(name));
            document.body.appendChild(div);

            try {
                code();
                div.setAttribute("style", "color: green;");
                __passedCases++;
            }
            catch (ex) {
                if (ex.message == "<EMPTY CASE>") {
                    div.setAttribute("style", "color: purple;");
                    __emptyCases++;
                }
                else {
                    div.setAttribute("style", "color: red;");
                    __failedCases++;
                    throw ex;
                }
            }
        }

        function emptyCase() {
            throw new Error("<EMPTY CASE>");
        }

        function summaryTest() {
            var container = document.createElement("div");
            container.setAttribute("style", "margin-top: 1.5em;");
            {
                var div = document.createElement("div");
                div.appendChild(document.createTextNode("=================================================="));
                div.setAttribute("style", "color: gray;");
                container.appendChild(div);
            }
            {
                var div = document.createElement("div");
                div.appendChild(document.createTextNode("Passed: " + __passedCases));
                div.setAttribute("style", "color: green; float: left");
                container.appendChild(div);
            }
            {
                var div = document.createElement("div");
                div.appendChild(document.createTextNode("\u00A0"));
                div.setAttribute("style", "min-width: 4em; float: left");
                container.appendChild(div);
            }
            {
                var div = document.createElement("div");
                div.appendChild(document.createTextNode("Failed: " + __failedCases));
                div.setAttribute("style", "color: red; float: left");
                container.appendChild(div);
            }
            {
                var div = document.createElement("div");
                div.appendChild(document.createTextNode("\u00A0"));
                div.setAttribute("style", "min-width: 4em; float: left");
                container.appendChild(div);
            }
            {
                var div = document.createElement("div");
                div.appendChild(document.createTextNode("Empty: " + __emptyCases));
                div.setAttribute("style", "color: purple; float: left");
                container.appendChild(div);
            }
            {
                var div = document.createElement("div");
                div.setAttribute("style", "claer: both");
                container.appendChild(div);
            }
            document.body.appendChild(container);
        }
    </script>

    <script>
        testCase("create instance should success", function () {
            var MyClass = Class("MyClass", {
            });

            var x = new MyClass();
            assert(x.__GetType() == MyClass);
        });
    </script>

    <script>
        testCase("fields cannot be deleted", function () {
            var MyClass = Class("MyClass", {
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            delete x.GetType;
            delete x.a;
            delete x.b;
            assert(x.__GetType() == MyClass);
            assert(x.a == 0);
            assert(x.b == 1);
        });
    </script>

    <script>
        testCase("instances don't share fields", function () {
            var MyClass = Class("MyClass", {
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            var y = new MyClass();
            assert(x.a == 0);
            assert(x.b == 1);
            assert(y.a == 0);
            assert(y.b == 1);

            x.a = 2;
            y.a = 3;
            assert(x.a == 2);
            assert(x.b == 1);
            assert(y.a == 3);
            assert(y.b == 1);
        });
    </script>

    <script>
        testCase("member function can access all members", function () {
            var MyClass = Class("MyClass", {
                value: Public(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            assert(x.value == 0);
            assert(x.GetValue() == 0);

            x.value = 1;
            assert(x.value == 1);
            assert(x.GetValue() == 1);

            x.SetValue(2);
            assert(x.value == 2);
            assert(x.GetValue() == 2);
        })
    </script>

    <script>
        testCase("protected members are not visible from outside", function () {
            var MyClass = Class("MyClass", {
                value: Protected(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            assert(x.value == undefined);
            assert(x.GetValue() == 0);

            x.value = 1;
            assert(x.value == 1);
            assert(x.GetValue() == 0);

            x.SetValue(2);
            assert(x.value == 1);
            assert(x.GetValue() == 2);
        })
    </script>

    <script>
        testCase("private members are not visible from derived classes", function () {
            var BaseClass = Class("BaseClass", {
                privateMember: Private(1),
                protectedMember: Protected(2),
                publicMember: Public(3),

                PrivateFunctionInternal: Private(function () {
                    return this.privateMember;
                }),

                ProtectedFunctionInternal: Protected(function () {
                    return this.protectedMember + this.privateMember;
                }),

                PublicFunctionInternal: Public(function () {
                    return this.publicMember + this.protectedMember + this.privateMember;
                }),

                PrivateFunctionBase: Private(function () {
                    return this.PrivateFunctionInternal();
                }),

                ProtectedFunctionBase: Protected(function () {
                    return this.ProtectedFunctionInternal();
                }),

                PublicFunctionBase: Public(function () {
                    return this.PublicFunctionInternal();
                }),
            });

            var DerivedClass = Class("DerivedClass", BaseClass, {
                PrivateFunction1: Public(function () {
                    return this.PrivateFunctionBase == undefined ? 0 : this.PrivateFunctionBase();
                }),

                ProtectedFunction1: Public(function () {
                    return this.ProtectedFunctionBase == undefined ? 0 : this.ProtectedFunctionBase();
                }),

                PublicFunction1: Public(function () {
                    return this.PublicFunctionBase == undefined ? 0 : this.PublicFunctionBase();
                }),

                PrivateFunction2: Public(function () {
                    return this.privateMember == undefined ? 0 : this.privateMember;
                }),

                ProtectedFunction2: Public(function () {
                    return this.protectedMember == undefined ? 0 : this.protectedMember;
                }),

                PublicFunction2: Public(function () {
                    return this.publicMember == undefined ? 0 : this.publicMember;
                }),
            });

            var x = new DerivedClass();
            assert(x.privateMember == undefined);
            assert(x.protectedMember == undefined);
            assert(x.publicMember == 3);

            assert(x.PrivateFunctionInternal == undefined);
            assert(x.ProtectedFunctionInternal == undefined);
            assert(x.PublicFunctionInternal() == 6);

            assert(x.PrivateFunctionBase == undefined);
            assert(x.ProtectedFunctionBase == undefined);
            assert(x.PublicFunctionBase() == 6);

            assert(x.PrivateFunction1() == 0);
            assert(x.ProtectedFunction1() == 3);
            assert(x.PublicFunction1() == 6);

            assert(x.PrivateFunction2() == 0);
            assert(x.ProtectedFunction2() == 2);
            assert(x.PublicFunction2() == 3);
        })
    </script>

    <script>
        testCase("deriving from a child class should success", function () {
            var A = Class("A", {
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.__GetType();
                }),
            });

            var B = Class("B", A, {
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.__GetType();
                }),
            });

            var C = Class("C", B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.__GetType();
                }),
            });

            assert(A.IsAssignableFrom(A) == true);
            assert(A.IsAssignableFrom(B) == true);
            assert(A.IsAssignableFrom(C) == true);
            assert(B.IsAssignableFrom(A) == false);
            assert(B.IsAssignableFrom(B) == true);
            assert(B.IsAssignableFrom(C) == true);
            assert(C.IsAssignableFrom(A) == false);
            assert(C.IsAssignableFrom(B) == false);
            assert(C.IsAssignableFrom(C) == true);

            var x = new C();
            assert(x.DoA(1, 2) == 3);
            assert(x.DoB(1, 2) == -1);
            assert(x.DoC(1, 2) == 2);
            assert(x.GetA() == C);
            assert(x.GetB() == C);
            assert(x.GetC() == C);
        });
    </script>

    <script>
        testCase("deriving from multiple classea should success", function () {
            var A = Class("A", {
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.__GetType();
                }),
            });

            var B = Class("B", {
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.__GetType();
                }),
            });

            var C = Class("C", A, B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.__GetType();
                }),
            });

            assert(A.IsAssignableFrom(A) == true);
            assert(A.IsAssignableFrom(B) == false);
            assert(A.IsAssignableFrom(C) == true);
            assert(B.IsAssignableFrom(A) == false);
            assert(B.IsAssignableFrom(B) == true);
            assert(B.IsAssignableFrom(C) == true);
            assert(C.IsAssignableFrom(A) == false);
            assert(C.IsAssignableFrom(B) == false);
            assert(C.IsAssignableFrom(C) == true);

            var x = new C();
            assert(x.DoA(1, 2) == 3);
            assert(x.DoB(1, 2) == -1);
            assert(x.DoC(1, 2) == 2);
            assert(x.GetA() == C);
            assert(x.GetB() == C);
            assert(x.GetC() == C);
        });
    </script>

    <script>
        testCase("functions should overload by argument types", function () {
            var A = Class("A", {
            });

            var B = Class("B", A, {
            });

            var C = Class("C", A, {
            });

            var MyClass = Class("MyClass", {
                Print: Private(function (args) {
                    var result = "";
                    for (var i in args) {
                        if (i > 0) result += ", ";
                        result += typeof (args[i]);
                    }
                    return result;
                }),

                Do: Public.Overload(
                    [], function () {
                        return "1: " + this.Print(arguments);
                    },
                    [Number, String, Boolean], function (a, b, c) {
                        return "2: " + this.Print(arguments);
                    },
                    [Function], function (x) {
                        return "3: " + this.Print(arguments);
                    },
                    [C], function (x) {
                        return "4: " + this.Print(arguments);
                    },
                    [B], function (x) {
                        return "5: " + this.Print(arguments);
                    },
                    [A], function (x) {
                        return "6: " + this.Print(arguments);
                    },
                    [Object], function (x) {
                        return "7: " + this.Print(arguments);
                    }
                ),
            });

            var a = new A();
            var b = new B();
            var c = new C();
            var x = new MyClass();
            assert(x.Do() == "1: ");
            assert(x.Do(1, "2", true) == "2: number, string, boolean");
            assert(x.Do(function () { }) == "3: function");
            assert(x.Do(c) == "4: object");
            assert(x.Do(b) == "5: object");
            assert(x.Do(a) == "6: object");
            assert(x.Do(null) == "7: object");
        });
    </script>

    <script>
        testCase("constructor should be called", function () {
            var MyClass = Class("MyClass", {
                value: Private(null),
                Get: Public(function () {
                    return this.value;
                }),
                __Constructor: Public.Overload(
                    [Number], function () {
                        this.value = "number";
                    },
                    [String], function () {
                        this.value = "string";
                    }
                ),
            });

            var x = new MyClass(1);
            var y = new MyClass("2");
            assert(x.Get() == "number");
            assert(y.Get() == "string");
        });
    </script>

    <script>
        testCase("constructors in base classes can be called by child class", function () {
            var A = Class("A", {
                value: Private(null),
                GetA: Public(function () {
                    return this.value;
                }),
                __Constructor: Public(function (x) {
                    this.value = x;
                })
            });

            var B = Class("B", {
                value: Private(null),
                GetB: Public(function () {
                    return this.value;
                }),
                __Constructor: Public(function (x) {
                    this.value = x;
                })
            });

            var C = Class("C", A, B, {
                Get: Public(function () {
                    return this.GetA() + this.GetB();
                }),
                __Constructor: Public(function (x, y) {
                    this.__GetBase(A).__Constructor(x);
                    this.__GetBase(B).__Constructor(y);
                })
            })

            var c = new C(1, 2);
            assert(c.Get() == 3);
        });
    </script>

    <script>
        testCase("Virtual function should be able to override in child classes", function () {
            var A = Class("A", {
                GetX: Protected.Virtual(function () {
                    return "X";
                }),
                GetY: Protected(function () {
                    return "Y";
                }),
                GetZ: Public(function () {
                    return this.GetX() + ", " + this.GetY();
                })
            });

            var B = Class("B", A, {
                GetX: Protected.Override(function () {
                    return "U";
                }),
                GetY: Protected(function () {
                    return "V";
                }),
            });

            var a = new A();
            var b = new B();
            assert(a.GetZ() == "X, Y");
            assert(b.GetZ() == "U, Y");
        });
    </script>

    <script>
        testCase("Abstract function should not be called and should be able to override in child classes.", function () {
            var A = Class("A", {
                GetX: Protected.Abstract(),
                GetY: Protected(function () {
                    return "Y";
                }),
                GetZ: Public(function () {
                    return this.GetX() + ", " + this.GetY();
                })
            });

            var B = Class("B", A, {
                GetX: Protected.Override(function () {
                    return "U";
                }),
                GetY: Protected(function () {
                    return "V";
                }),
            });

            var a = new A();
            var b = new B();
            try {
                a.GetZ();
                assert(false);
            }
            catch (ex) {
                assert(ex.message == "Cannot call an abstract function.");
            }
            assert(b.GetZ() == "U, Y");
        });
    </script>

    <script>
        testCase("<new and new virtual>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<virtual function in multiple inheritance>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<virtual base class>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<constructor in virtual base classes>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<properties>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<events>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<hidden member in base classes>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<cannot non-virtually inherit a class multiple times>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<cannot inherit multiple members of the same name without defining a new one>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<Cannot override non-virtual functions>", function () {
            emptyCase();
        });
    </script>

    <script>
        testCase("<Cannot hide a virtual function without overriding>", function () {
            emptyCase();
        });
    </script>

    <script>
        summaryTest();
    </script>
</body>
</html>
