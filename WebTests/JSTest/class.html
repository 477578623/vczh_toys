<!DOCTYPE html>
<html>
<head>
    <title>Class</title>
</head>
<body>
    <script>
        function __MemberBase() {
        }
        Object.defineProperty(__MemberBase.prototype, "DeclaringType", {
            configurable: false,
            enumerable: true,
            writable: true,
            value: null,
        });

        function __PrivateMember(value) {
            this.value = value;
        }
        __PrivateMember.prototype.__proto__ = __MemberBase.prototype;

        function __ProtectedMember(value) {
            this.value = value;
        }
        __ProtectedMember.prototype.__proto__ = __MemberBase.prototype;

        function __PublicMember(value) {
            this.value = value;
        }
        __PublicMember.prototype.__proto__ = __MemberBase.prototype;

        function __BuildOverloadingFunctions() {
            if (arguments.length % 2 != 0) {
                throw new Error("Arguments for Overload should be typeList1, func1, typeList2, func2, ...");
            }

            var functionCount = Math.floor(arguments.length / 2);
            var typeLists = new Array(functionCount);
            var funcs = new Array(functionCount);
            for (var i = 0; i < functionCount; i++) {
                typeLists[i] = arguments[i * 2];
                funcs[i] = arguments[i * 2 + 1];
            }

            return function () {
                for (var i in typeLists) {
                    var typeList = typeLists[i];
                    if (arguments.length != typeList.length) continue;

                    var matched = true;
                    for (var j in typeList) {
                        if (!matched) break;
                        var arg = arguments[j];

                        var type = typeList[j];
                        if (type == Number) {
                            matched = typeof (arg) == "number";
                        }
                        else if (type == Boolean) {
                            matched = typeof (arg) == "boolean";
                        }
                        else if (type == String) {
                            matched = typeof (arg) == "string";
                        }
                        else if (type == Array) {
                            matched = arg instanceof Array;
                        }
                        else if (type == Function) {
                            matched = typeof (arg) == "function";
                        }
                        else if (type == Object) {
                            matched = typeof (arg) == "object";
                        }
                        else if (arg == undefined) {
                            matched = false;
                        }
                        else if (arg != null) {
                            if (type.prototype.__proto__ == Class) {
                                if (arg instanceof Class) {
                                    matched = type.IsAssignableFrom(arg.GetType());
                                }
                                else {
                                    matched = false;
                                }
                            }
                            else {
                                matched = arg instanceof type;
                            }
                        }
                    }

                    if (matched) {
                        return funcs[i].apply(this, arguments);
                    }
                }
                throw new Error("Cannot find a overloading function that matches the arguments.");
            }
        }

        function __DefineOverload(accessor) {
            Object.defineProperty(accessor, "Overload", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return accessor(__BuildOverloadingFunctions.apply(null, arguments));
                }
            });
        }

        // Abstract, Virtual, Override

        function Private(value) {
            return new __PrivateMember(value);
        }
        __DefineOverload(Private);

        function Protected(value) {
            return new __ProtectedMember(value);
        }
        __DefineOverload(Protected);

        function Public(value) {
            return new __PublicMember(value);
        }
        __DefineOverload(Public);

        function Class() {

            function CreateInternalReference(description) {
                var internalReference = {};

                for (var name in description) {
                    var member = description[name];

                    if (member instanceof __PrivateMember) {
                        internalReference[name] = member.value;
                    }
                    else if (member instanceof __ProtectedMember) {
                        internalReference[name] = member.value;
                    }
                    else if (member instanceof __PublicMember) {
                        internalReference[name] = member.value;
                    }
                }

                return internalReference;
            }

            function CopyReferencableMember(target, source, memberName, memberValue) {
                if (typeof memberValue == "function") {
                    Object.defineProperty(target, memberName, {
                        configurable: false,
                        enumerable: true,
                        writable: false,
                        value: function () {
                            return memberValue.apply(source, arguments);
                        }
                    });
                }
                else {
                    Object.defineProperty(target, memberName, {
                        configurable: false,
                        enumerable: true,
                        get: function () {
                            return source[memberName];
                        },
                        set: function (value) {
                            source[memberName] = value;
                        }
                    });
                }
            }

            function CopyReferencableMembers(target, source, description, forInternalReference) {
                for (var name in description) {
                    if (name != "__Constructor") {
                        (function () {
                            var memberName = name;
                            var member = description[memberName];

                            if (member instanceof __ProtectedMember) {
                                if (forInternalReference) {
                                    CopyReferencableMember(target, source, memberName, member.value);
                                }
                            }
                            else if (member instanceof __PublicMember) {
                                CopyReferencableMember(target, source, memberName, member.value);
                            }
                        })();
                    }
                }
            }

            function CreateCompleteInternalReference(type, accumulatedBaseClasses, accumulatedBaseReferences) {
                var description = type.GetDescription();
                var baseClasses = type.GetBaseClasses();
                var baseInstances = new Array(baseClasses.length);

                for (var i = 0; i <= baseClasses.length; i++) {
                    if (i == baseClasses.length) {
                        var internalReference = CreateInternalReference(description);

                        for (var j = 0; j < accumulatedBaseClasses.length; j++) {
                            CopyReferencableMembers(
                                internalReference,
                                accumulatedBaseReferences[j],
                                accumulatedBaseClasses[j].GetDescription(),
                                true);
                        }

                        accumulatedBaseClasses.push(type);
                        accumulatedBaseReferences.push(internalReference);

                        internalReference.__GetBase = function (baseType) {
                            for (var k in baseClasses) {
                                if (baseClasses[k] == baseType) {
                                    return baseInstances[k];
                                }
                            }
                            return undefined;
                        }

                        return internalReference;
                    }
                    else {
                        var baseInstance = CreateCompleteInternalReference(
                            baseClasses[i],
                            accumulatedBaseClasses,
                            accumulatedBaseReferences);
                        baseInstances[i] = baseInstance;
                    }
                }
            }

            function InjectInternalReference(internalReference, typeObject, externalReference) {
                internalReference.__GetType = function () {
                    return typeObject;
                }

                internalReference.__GetExternalReference = function () {
                    return externalReference;
                }
            }

            var directBaseClasses = new Array(arguments.length - 1);
            for (var i = 0; i < arguments.length - 1; i++) {
                directBaseClasses[i] = arguments[i];
            }
            var description = arguments[arguments.length - 1];

            function Type() {
                var typeObject = arguments.callee;

                // create every internalReference, which is the value of "this" in member functions
                var accumulatedBaseClasses = [];
                var accumulatedBaseReferences = [];
                var internalReference = CreateCompleteInternalReference(
                    typeObject,
                    accumulatedBaseClasses,
                    accumulatedBaseReferences);

                // create the externalReference
                var externalReference = {};

                // inject externalReference.GetType()
                Object.defineProperty(externalReference, "__GetType", {
                    configurable: false,
                    enumerable: true,
                    writable: false,
                    value: function () {
                        return typeObject;
                    }
                });

                // inject internalReference.GetType()
                // inject internalReference.GetExternalReference()
                for (var i in accumulatedBaseReferences) {
                    InjectInternalReference(accumulatedBaseReferences[i], typeObject, externalReference);
                }

                // copy all public member fields to externalReference
                for (var i in accumulatedBaseReferences) {
                    CopyReferencableMembers(
                        externalReference,
                        accumulatedBaseReferences[i],
                        accumulatedBaseClasses[i].GetDescription(),
                        false);
                }

                // return the externalReference
                externalReference.__proto__ = typeObject.prototype;
                if (internalReference.hasOwnProperty("__Constructor")) {
                    internalReference.__Constructor.apply(internalReference, arguments);
                }
                return externalReference;
            }

            for (var name in description) {
                description[name].DeclaringType = Type;
            }

            var flattenedBaseClasses = [];
            function AddFlattenedBaseClass(type) {
                if (flattenedBaseClasses.indexOf(type) == -1) {
                    flattenedBaseClasses.push(type);
                }
                else {
                    throw new Error("Cannot non-virtually inherit from a type multiple times.");
                }
            }

            for (var i in directBaseClasses) {
                var baseClass = directBaseClasses[i];
                var baseFlattened = baseClass.GetFlattenedBaseClasses();
                for (var j in baseFlattened) {
                    AddFlattenedBaseClass(baseFlattened[j]);
                }
                AddFlattenedBaseClass(baseClass);
            }

            var flattenedDescription = {};
            function AddFlattenedMember(name, member, addPrivateMember) {
                if (name != "__Constructor" && (addPrivateMember || !(member instanceof __PrivateMember))) {
                    if (flattenedDescription.hasOwnProperty(name)) {
                        throw new Error("Cannot define or inherit multiple members using the same name \"" + name + "\".");
                    }
                    else {
                        flattenedDescription[name] = member;
                    }
                }
            }

            for (var i in directBaseClasses) {
                var baseClass = directBaseClasses[i];
                var flattened = baseClass.GetFlattenedDescription();
                for (var j in flattened) {
                    AddFlattenedMember(j, flattened[j], false);
                }
            }
            for (var j in description) {
                AddFlattenedMember(j, description[j], true);
            }

            Object.defineProperty(Type, "GetDescription", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return description;
                }
            });

            Object.defineProperty(Type, "GetFlattenedDescription", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return flattenedDescription;
                }
            });

            Object.defineProperty(Type, "GetBaseClasses", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return directBaseClasses;
                }
            });

            Object.defineProperty(Type, "GetFlattenedBaseClasses", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return flattenedBaseClasses;
                }
            });

            Object.defineProperty(Type, "IsAssignableFrom", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function (type) {
                    if (type == Type) {
                        return true;
                    }
                    else {
                        var baseClasses = type.GetBaseClasses();
                        for (var i in baseClasses) {
                            if (Type.IsAssignableFrom(baseClasses[i])) {
                                return true;
                            }
                        }
                        return false;
                    }
                }
            });

            Type.prototype.__proto__ = Class.prototype;
            return Type;
        }

        /*
        API:
            this.__GetType()
            this.__GetBase(type)
            this.__GetExternalReference()

            Type.GetDescription()
            Type.GetFlattenedDescription()
            Type.GetBaseClasses()
            Type.GetFlattenedBaseClasses()
            Type.IsAssignableFrom(type)

            Class(type1, type2, ... {
                Member: (Public|Protected|Private) (value | function),
                Member: (Public|Protected|Private)[.(Virtual|Override)] (function),
                Member: (Public|Protected|Private).Overload(typeList1, function1, typeList2, function2, ...);
                Member: (Public|Protected).Abstract();
                Member: Public.Event();
                Member: Public.Property({
                    readonly: true | false,             // (optional, false)
                    hasEvent: true | false,             // (optional, false)
                    getterName: "GetterNameToOverride", // (optional, "GetMember")
                    setterName: "SetterNameToOverride", // (optional, "SetMember")      implies readonly: false
                    eventName: "EventNameToOverride",   // (optional, "MemberChanged")  implies hasEvent: true
                }),
            });
        */
    </script>
    <script>
        function assert(code) {
            if (!code) throw new Error("Fuck");
        }

        function testCase(name, code) {
            console.debug("Running: " + name);
            code();
        }
    </script>

    <script>
        testCase("create instance should success", function () {
            var MyClass = Class({
            });

            var x = new MyClass();
            assert(x.__GetType() == MyClass);
        });
    </script>

    <script>
        testCase("fields cannot be deleted", function () {
            var MyClass = Class({
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            delete x.GetType;
            delete x.a;
            delete x.b;
            assert(x.__GetType() == MyClass);
            assert(x.a == 0);
            assert(x.b == 1);
        });
    </script>

    <script>
        testCase("instances don't share fields", function () {
            var MyClass = Class({
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            var y = new MyClass();
            assert(x.a == 0);
            assert(x.b == 1);
            assert(y.a == 0);
            assert(y.b == 1);

            x.a = 2;
            y.a = 3;
            assert(x.a == 2);
            assert(x.b == 1);
            assert(y.a == 3);
            assert(y.b == 1);
        });
    </script>

    <script>
        testCase("member function can access all members", function () {
            var MyClass = Class({
                value: Public(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            assert(x.value == 0);
            assert(x.GetValue() == 0);

            x.value = 1;
            assert(x.value == 1);
            assert(x.GetValue() == 1);

            x.SetValue(2);
            assert(x.value == 2);
            assert(x.GetValue() == 2);
        })
    </script>

    <script>
        testCase("protected members are not visible from outside", function () {
            var MyClass = Class({
                value: Protected(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            assert(x.value == undefined);
            assert(x.GetValue() == 0);

            x.value = 1;
            assert(x.value == 1);
            assert(x.GetValue() == 0);

            x.SetValue(2);
            assert(x.value == 1);
            assert(x.GetValue() == 2);
        })
    </script>

    <script>
        testCase("private members are not visible from derived classes", function () {
            var BaseClass = Class({
                privateMember: Private(1),
                protectedMember: Protected(2),
                publicMember: Public(3),

                PrivateFunctionInternal: Private(function () {
                    return this.privateMember;
                }),

                ProtectedFunctionInternal: Protected(function () {
                    return this.protectedMember + this.privateMember;
                }),

                PublicFunctionInternal: Public(function () {
                    return this.publicMember + this.protectedMember + this.privateMember;
                }),

                PrivateFunctionBase: Private(function () {
                    return this.PrivateFunctionInternal();
                }),

                ProtectedFunctionBase: Protected(function () {
                    return this.ProtectedFunctionInternal();
                }),

                PublicFunctionBase: Public(function () {
                    return this.PublicFunctionInternal();
                }),
            });

            var DerivedClass = Class(BaseClass, {
                PrivateFunction1: Public(function () {
                    return this.PrivateFunctionBase == undefined ? 0 : this.PrivateFunctionBase();
                }),

                ProtectedFunction1: Public(function () {
                    return this.ProtectedFunctionBase == undefined ? 0 : this.ProtectedFunctionBase();
                }),

                PublicFunction1: Public(function () {
                    return this.PublicFunctionBase == undefined ? 0 : this.PublicFunctionBase();
                }),

                PrivateFunction2: Public(function () {
                    return this.privateMember == undefined ? 0 : this.privateMember;
                }),

                ProtectedFunction2: Public(function () {
                    return this.protectedMember == undefined ? 0 : this.protectedMember;
                }),

                PublicFunction2: Public(function () {
                    return this.publicMember == undefined ? 0 : this.publicMember;
                }),
            });

            var x = new DerivedClass();
            assert(x.privateMember == undefined);
            assert(x.protectedMember == undefined);
            assert(x.publicMember == 3);

            assert(x.PrivateFunctionInternal == undefined);
            assert(x.ProtectedFunctionInternal == undefined);
            assert(x.PublicFunctionInternal() == 6);

            assert(x.PrivateFunctionBase == undefined);
            assert(x.ProtectedFunctionBase == undefined);
            assert(x.PublicFunctionBase() == 6);

            assert(x.PrivateFunction1() == 0);
            assert(x.ProtectedFunction1() == 3);
            assert(x.PublicFunction1() == 6);

            assert(x.PrivateFunction2() == 0);
            assert(x.ProtectedFunction2() == 2);
            assert(x.PublicFunction2() == 3);
        })
    </script>

    <script>
        testCase("deriving from a child class should success", function () {
            var A = Class({
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.__GetType();
                }),
            });

            var B = Class(A, {
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.__GetType();
                }),
            });

            var C = Class(B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.__GetType();
                }),
            });

            assert(A.IsAssignableFrom(A) == true);
            assert(A.IsAssignableFrom(B) == true);
            assert(A.IsAssignableFrom(C) == true);
            assert(B.IsAssignableFrom(A) == false);
            assert(B.IsAssignableFrom(B) == true);
            assert(B.IsAssignableFrom(C) == true);
            assert(C.IsAssignableFrom(A) == false);
            assert(C.IsAssignableFrom(B) == false);
            assert(C.IsAssignableFrom(C) == true);

            var x = new C();
            assert(x.DoA(1, 2) == 3);
            assert(x.DoB(1, 2) == -1);
            assert(x.DoC(1, 2) == 2);
            assert(x.GetA() == C);
            assert(x.GetB() == C);
            assert(x.GetC() == C);
        });
    </script>

    <script>
        testCase("deriving from multiple classea should success", function () {
            var A = Class({
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.__GetType();
                }),
            });

            var B = Class({
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.__GetType();
                }),
            });

            var C = Class(A, B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.__GetType();
                }),
            });

            assert(A.IsAssignableFrom(A) == true);
            assert(A.IsAssignableFrom(B) == false);
            assert(A.IsAssignableFrom(C) == true);
            assert(B.IsAssignableFrom(A) == false);
            assert(B.IsAssignableFrom(B) == true);
            assert(B.IsAssignableFrom(C) == true);
            assert(C.IsAssignableFrom(A) == false);
            assert(C.IsAssignableFrom(B) == false);
            assert(C.IsAssignableFrom(C) == true);

            var x = new C();
            assert(x.DoA(1, 2) == 3);
            assert(x.DoB(1, 2) == -1);
            assert(x.DoC(1, 2) == 2);
            assert(x.GetA() == C);
            assert(x.GetB() == C);
            assert(x.GetC() == C);
        });
    </script>

    <script>
        testCase("functions should overload by argument types", function () {
            var A = Class({
            });

            var B = Class(A, {
            });

            var C = Class(A, {
            });

            var MyClass = Class({
                Print: Private(function (args) {
                    var result = "";
                    for (var i in args) {
                        if (i > 0) result += ", ";
                        result += typeof (args[i]);
                    }
                    return result;
                }),

                Do: Public.Overload(
                    [], function () {
                        return "1: " + this.Print(arguments);
                    },
                    [Number, String, Boolean], function (a, b, c) {
                        return "2: " + this.Print(arguments);
                    },
                    [Function], function (x) {
                        return "3: " + this.Print(arguments);
                    },
                    [C], function (x) {
                        return "4: " + this.Print(arguments);
                    },
                    [B], function (x) {
                        return "5: " + this.Print(arguments);
                    },
                    [A], function (x) {
                        return "6: " + this.Print(arguments);
                    },
                    [Object], function (x) {
                        return "7: " + this.Print(arguments);
                    }
                ),
            });

            var a = new A();
            var b = new B();
            var c = new C();
            var x = new MyClass();
            assert(x.Do() == "1: ");
            assert(x.Do(1, "2", true) == "2: number, string, boolean");
            assert(x.Do(function () { }) == "3: function");
            assert(x.Do(c) == "4: object");
            assert(x.Do(b) == "5: object");
            assert(x.Do(a) == "6: object");
            assert(x.Do(null) == "7: object");
        });
    </script>

    <script>
        testCase("constructor should be called", function () {
            var MyClass = Class({
                value: Private(null),
                Get: Public(function () {
                    return this.value;
                }),
                __Constructor: Public.Overload(
                    [Number], function () {
                        this.value = "number";
                    },
                    [String], function () {
                        this.value = "string";
                    }
                ),
            });

            var x = new MyClass(1);
            var y = new MyClass("2");
            assert(x.Get() == "number");
            assert(y.Get() == "string");
        });
    </script>

    <script>
        testCase("constructors in base classes can be called by child class", function () {
            var A = Class({
                value: Private(null),
                GetA: Public(function () {
                    return this.value;
                }),
                __Constructor: Public(function (x) {
                    this.value = x;
                })
            });

            var B = Class({
                value: Private(null),
                GetB: Public(function () {
                    return this.value;
                }),
                __Constructor: Public(function (x) {
                    this.value = x;
                })
            });

            var C = Class(A, B, {
                Get: Public(function () {
                    return this.GetA() + this.GetB();
                }),
                __Constructor: Public(function (x, y) {
                    this.__GetBase(A).__Constructor(x);
                    this.__GetBase(B).__Constructor(y);
                })
            })

            var c = new C(1, 2);
            assert(c.Get() == 3);
        });
    </script>

    <script>
        testCase("<virtual function>", function () {
        });
    </script>

    <script>
        testCase("<virtual function in multiple inheritance>", function () {
        });
    </script>

    <script>
        testCase("<virtual base class>", function () {
        });
    </script>

    <script>
        testCase("<constructor in virtual base classes>", function () {
        });
    </script>

    <script>
        testCase("<properties>", function () {
        });
    </script>

    <script>
        testCase("<events>", function () {
        });
    </script>

    <script>
        testCase("<hidden member in base classes>", function () {
        });
    </script>
</body>
</html>