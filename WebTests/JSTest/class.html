<!DOCTYPE html>
<html>
<head>
    <title>Class</title>
</head>
<body>
    <script>
        function __PrivateMember(value) {
            this.value = value;
        }

        function __ProtectedMember(value) {
            this.value = value;
        }

        function __PublicMember(value) {
            this.value = value;
        }

        // Overload, Abstract, Virtual, Override

        function Private(value) {
            return new __PrivateMember(value);
        }

        function Protected(value) {
            return new __ProtectedMember(value);
        }

        function Public(value) {
            return new __PublicMember(value);
        }

        function Class() {

            function CreateInternalReference(description) {
                var internalReference = {};
                internalReference.__proto__ = Class.prototype;

                for (var name in description) {
                    var member = description[name];

                    if (member instanceof __PrivateMember) {
                        internalReference[name] = member.value;
                    }
                    else if (member instanceof __ProtectedMember) {
                        internalReference[name] = member.value;
                    }
                    else if (member instanceof __PublicMember) {
                        internalReference[name] = member.value;
                    }
                }

                return internalReference;
            }

            function CopyReferencableMember(target, source, memberName, memberValue) {
                if (typeof memberValue == "function") {
                    Object.defineProperty(target, memberName, {
                        configurable: false,
                        enumerable: true,
                        writable: false,
                        value: function () {
                            return memberValue.apply(source, arguments);
                        }
                    });
                }
                else {
                    Object.defineProperty(target, memberName, {
                        configurable: false,
                        enumerable: true,
                        get: function () {
                            return source[memberName];
                        },
                        set: function (value) {
                            source[memberName] = value;
                        }
                    });
                }
            }

            function CopyReferencableMembers(target, source, description, copyProtected) {
                for (var name in description) {
                    (function () {
                        var memberName = name;
                        var member = description[memberName];

                        if (member instanceof __ProtectedMember) {
                            if (copyProtected) {
                                CopyReferencableMember(target, source, memberName, member.value);
                            }
                        }
                        else if (member instanceof __PublicMember) {
                            CopyReferencableMember(target, source, memberName, member.value);
                        }
                    })();
                }
            }

            function CreateCompleteInternalReference(type, accumulatedBaseClasses, accumulatedBaseReferences) {
                var description = type.GetDescription();
                var baseClasses = type.GetBaseClasses();

                for (var i = 0; i <= baseClasses.length; i++) {
                    if (i == baseClasses.length) {
                        var internalReference = CreateInternalReference(description);

                        for (var j = 0; j < accumulatedBaseClasses.length; j++) {
                            CopyReferencableMembers(
                                internalReference,
                                accumulatedBaseReferences[j],
                                accumulatedBaseClasses[j].GetDescription(),
                                true);
                        }

                        accumulatedBaseClasses.push(type);
                        accumulatedBaseReferences.push(internalReference);
                        return internalReference;
                    }
                    else {
                        CreateCompleteInternalReference(
                            baseClasses[i],
                            accumulatedBaseClasses,
                            accumulatedBaseReferences);
                    }
                }
            }

            function InjectInternalReference(internalReference, typeObject, externalReference) {
                internalReference.GetType = function () {
                    return typeObject;
                }

                internalReference.GetExternalReference = function () {
                    return externalReference;
                }
            }

            var directBaseClasses = new Array(arguments.length - 1);
            for (var i = 0; i < arguments.length - 1; i++) {
                directBaseClasses[i] = arguments[i];
            }
            var description = arguments[arguments.length - 1];

            function Type() {
                var typeObject = arguments.callee;

                // create every internalReference, which is the value of "this" in member functions
                var accumulatedBaseClasses = [];
                var accumulatedBaseReferences = [];
                var internalReference = CreateCompleteInternalReference(
                    typeObject,
                    accumulatedBaseClasses,
                    accumulatedBaseReferences);

                // create the externalReference
                var externalReference = {};

                // inject externalReference.GetType()
                Object.defineProperty(externalReference, "GetType", {
                    configurable: false,
                    enumerable: true,
                    writable: false,
                    value: function () {
                        return typeObject;
                    }
                });

                // inject internalReference.GetType()
                // inject internalReference.GetExternalReference()
                for (var i in accumulatedBaseReferences) {
                    InjectInternalReference(accumulatedBaseReferences[i], typeObject, externalReference);
                }

                // copy all public member fields to externalReference
                for (var i in accumulatedBaseReferences) {
                    CopyReferencableMembers(
                        externalReference,
                        accumulatedBaseReferences[i],
                        accumulatedBaseClasses[i].GetDescription(),
                        false);
                }

                // return the externalReference
                return externalReference;
            }

            Object.defineProperty(Type, "GetDescription", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return description;
                }
            });

            Object.defineProperty(Type, "GetBaseClasses", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function () {
                    return directBaseClasses;
                }
            });

            Object.defineProperty(Type, "IsAssignableFrom", {
                configurable: false,
                enumerable: true,
                writable: false,
                value: function (type) {
                    if (type == Type) {
                        return true;
                    }
                    else {
                        var baseClasses = type.GetBaseClasses();
                        for (var i in baseClasses) {
                            if (Type.IsAssignableFrom(baseClasses[i])) {
                                return true;
                            }
                        }
                        return false;
                    }
                }
            });
            return Type;
        }
    </script>
    <script>
        function assert(code) {
            if (!code) throw new Error("Fuck");
        }

        function testCase(name, code) {
            console.debug("Running: " + name);
            code();
        }
    </script>

    <script>
        testCase("create instance should success", function () {
            var MyClass = Class({
            });

            var x = new MyClass();
            assert(x.GetType() == MyClass);
        });
    </script>

    <script>
        testCase("fields cannot be deleted", function () {
            var MyClass = Class({
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            delete x.GetType;
            delete x.a;
            delete x.b;
            assert(x.GetType() == MyClass);
            assert(x.a == 0);
            assert(x.b == 1);
        });
    </script>

    <script>
        testCase("instances don't share fields", function () {
            var MyClass = Class({
                a: Public(0),
                b: Public(1),
            });

            var x = new MyClass();
            var y = new MyClass();
            assert(x.a == 0);
            assert(x.b == 1);
            assert(y.a == 0);
            assert(y.b == 1);

            x.a = 2;
            y.a = 3;
            assert(x.a == 2);
            assert(x.b == 1);
            assert(y.a == 3);
            assert(y.b == 1);
        });
    </script>

    <script>
        testCase("member function can access all members", function () {
            var MyClass = Class({
                value: Public(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            assert(x.value == 0);
            assert(x.GetValue() == 0);

            x.value = 1;
            assert(x.value == 1);
            assert(x.GetValue() == 1);

            x.SetValue(2);
            assert(x.value == 2);
            assert(x.GetValue() == 2);
        })
    </script>

    <script>
        testCase("protected members are not visible from outside", function () {
            var MyClass = Class({
                value: Protected(0),
                GetValue: Public(function () {
                    return this.value;
                }),
                SetValue: Public(function (newValue) {
                    this.value = newValue;
                }),
            });

            var x = new MyClass();
            assert(x.value == undefined);
            assert(x.GetValue() == 0);

            x.value = 1;
            assert(x.value == 1);
            assert(x.GetValue() == 0);

            x.SetValue(2);
            assert(x.value == 1);
            assert(x.GetValue() == 2);
        })
    </script>

    <script>
        testCase("private members are not visible from derived classes", function () {
            var BaseClass = Class({
                privateMember: Private(1),
                protectedMember: Protected(2),
                publicMember: Public(3),

                PrivateFunctionInternal: Private(function () {
                    return this.privateMember;
                }),

                ProtectedFunctionInternal: Protected(function () {
                    return this.protectedMember + this.privateMember;
                }),

                PublicFunctionInternal: Public(function () {
                    return this.publicMember + this.protectedMember + this.privateMember;
                }),

                PrivateFunctionBase: Private(function () {
                    return this.PrivateFunctionInternal();
                }),

                ProtectedFunctionBase: Protected(function () {
                    return this.ProtectedFunctionInternal();
                }),

                PublicFunctionBase: Public(function () {
                    return this.PublicFunctionInternal();
                }),
            });

            var DerivedClass = Class(BaseClass, {
                PrivateFunction1: Public(function () {
                    return this.PrivateFunctionBase == undefined ? 0 : this.PrivateFunctionBase();
                }),

                ProtectedFunction1: Public(function () {
                    return this.ProtectedFunctionBase == undefined ? 0 : this.ProtectedFunctionBase();
                }),

                PublicFunction1: Public(function () {
                    return this.PublicFunctionBase == undefined ? 0 : this.PublicFunctionBase();
                }),

                PrivateFunction2: Public(function () {
                    return this.privateMember == undefined ? 0 : this.privateMember;
                }),

                ProtectedFunction2: Public(function () {
                    return this.protectedMember == undefined ? 0 : this.protectedMember;
                }),

                PublicFunction2: Public(function () {
                    return this.publicMember == undefined ? 0 : this.publicMember;
                }),
            });

            var x = new DerivedClass();
            assert(x.privateMember == undefined);
            assert(x.protectedMember == undefined);
            assert(x.publicMember == 3);

            assert(x.PrivateFunctionInternal == undefined);
            assert(x.ProtectedFunctionInternal == undefined);
            assert(x.PublicFunctionInternal() == 6);

            assert(x.PrivateFunctionBase == undefined);
            assert(x.ProtectedFunctionBase == undefined);
            assert(x.PublicFunctionBase() == 6);

            assert(x.PrivateFunction1() == 0);
            assert(x.ProtectedFunction1() == 3);
            assert(x.PublicFunction1() == 6);

            assert(x.PrivateFunction2() == 0);
            assert(x.ProtectedFunction2() == 2);
            assert(x.PublicFunction2() == 3);
        })
    </script>

    <script>
        testCase("deriving from a child class should success", function () {
            var A = Class({
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.GetType();
                }),
            });

            var B = Class(A, {
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.GetType();
                }),
            });

            var C = Class(B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.GetType();
                }),
            });

            assert(A.IsAssignableFrom(A) == true);
            assert(A.IsAssignableFrom(B) == true);
            assert(A.IsAssignableFrom(C) == true);
            assert(B.IsAssignableFrom(A) == false);
            assert(B.IsAssignableFrom(B) == true);
            assert(B.IsAssignableFrom(C) == true);
            assert(C.IsAssignableFrom(A) == false);
            assert(C.IsAssignableFrom(B) == false);
            assert(C.IsAssignableFrom(C) == true);

            var x = new C();
            assert(x.DoA(1, 2) == 3);
            assert(x.DoB(1, 2) == -1);
            assert(x.DoC(1, 2) == 2);
            assert(x.GetA() == C);
            assert(x.GetB() == C);
            assert(x.GetC() == C);
        });
    </script>

    <script>
        testCase("deriving from multiple classea should success", function () {
            var A = Class({
                DoA: Public(function (a, b) {
                    return a + b;
                }),
                GetA: Public(function () {
                    return this.GetType();
                }),
            });

            var B = Class({
                DoB: Public(function (a, b) {
                    return a - b;
                }),
                GetB: Public(function () {
                    return this.GetType();
                }),
            });

            var C = Class(A, B, {
                DoC: Public(function (a, b) {
                    return a * b;
                }),
                GetC: Public(function () {
                    return this.GetType();
                }),
            });

            assert(A.IsAssignableFrom(A) == true);
            assert(A.IsAssignableFrom(B) == false);
            assert(A.IsAssignableFrom(C) == true);
            assert(B.IsAssignableFrom(A) == false);
            assert(B.IsAssignableFrom(B) == true);
            assert(B.IsAssignableFrom(C) == true);
            assert(C.IsAssignableFrom(A) == false);
            assert(C.IsAssignableFrom(B) == false);
            assert(C.IsAssignableFrom(C) == true);

            var x = new C();
            assert(x.DoA(1, 2) == 3);
            assert(x.DoB(1, 2) == -1);
            assert(x.DoC(1, 2) == 2);
            assert(x.GetA() == C);
            assert(x.GetB() == C);
            assert(x.GetC() == C);
        });
    </script>

    <script>
        testCase("functions should overload by argument types", function () {
            var A = Class({
            });

            var B = Class(A, {
            });

            var C = Class(A, {
            });

            var MyClass = Class({
                Print:Private(function() {
                    var result = "";
                    for (var i in arguments) {
                        if (i > 0) result += ", ";
                        result += typeof (arguments[i]);
                    }
                    return result;
                }),

                Do: Public.Overload(
                    [], function () {
                        return "1: " + this.Print(arguments);
                    },
                    [Number, String, Boolean], function (a, b, c) {
                        return "2: " + this.Print(arguments);
                    },
                    [Function], function (x) {
                        return "3: " + this.Print(arguments);
                    },
                    [C], function (x) {
                        return "4: " + this.Print(arguments);
                    },
                    [B], function (x) {
                        return "5: " + this.Print(arguments);
                    },
                    [A], function (x) {
                        return "6: " + this.Print(arguments);
                    },
                    [Object], function (x) {
                        return "7: " + this.Print(arguments);
                    }
                ),
            });
        });
    </script>

    <script>
        testCase("<constructor>", function () {
        });
    </script>

    <script>
        testCase("<virtual function>", function () {
        });
    </script>

    <script>
        testCase("<virtual function in multiple inheritance>", function () {
        });
    </script>

    <script>
        testCase("<virtual base class>", function () {
        });
    </script>

    <script>
        testCase("<constructor in virtual base class>", function () {
        });
    </script>

    <script>
        testCase("<properties>", function () {
        });
    </script>

    <script>
        testCase("<events>", function () {
        });
    </script>
</body>
</html>