# 专栏设想
等GacUI 1.0 release之后，当做完新的parser gen和Gac UI中intellisense的支持之后，写一个专栏，从模拟一台电脑开始，一步一步做到动态语言。

## 虚拟机
- 拥有固定大小的内存、硬盘空间和显示器，有足够的指令和中断去操作他们，所有缓存都从内存中切割出来。
- 虚拟机启动的时候从硬盘的0位开始加载程序，然后执行。
- 堆栈从最右开始向左移动。

## 64位指令集
- 寄存器：r0, r1, f0, f1, s0, s1, i
- LDI <__int64>: 加载一个整数到r0。
- LDF <double>：加载一个浮点数到f0。
- I2F：从f0转整形到r0。
- F2I：从r0转浮点到f0。
- SWPI：r0和r1交换。
- SWPF：f0和f1交换。
- ADDS, ADDU, ADDF：加法，结果存放在0号寄存器。
  - 还有SUB, MUL, DIV, MOD（没有浮点）
  - AND, OR, XOR（没有浮点）
  - NEG（*-1）
  - REV（^0xFFFFFFFF，没有浮点）
- R1, R2, R4, R8, RF4, RF8：把r0指向的内存中的数据按不同的类型写进0号寄存器。
- W1, W2, W4, W8, WF4, WF8：把0号寄存器的内容按不同的类型写进r0指向的内存中。
- CS, CU, CF：把0和1号寄存器的数据进行比较，结果写进r0（小于为-1，等于为0，大于为1）。
- C0：把r0与0进行比较，如果不等于0，把r0改写为0xFFFFFFFF。
- JZN：当r0为0的时候，把下一条指令的地址写进r0，跳转到地址（r0+有符号整数r1的结果）。
- JZF：当r0为0的时候，把下一条指令的地址写进r0，跳转到地址（r1）。
- CALL <__int64>：利用r0保存的地址信息，在堆栈上开辟足够的空间，并且留出参数那么大的自由空间。
- RET：撤销上一次CALL的堆栈分配并返回到CALL指令记录下来的r0地址。如果r0为0xFFFFFFFF，则关机。
- LS：把s1复制进r0。假设CALL指令为x，那么[r0, r0+x)为堆栈的自由空间，可任意修改。
- INIT <__int64>：初始化（s0设置为可用内存最大值，r0r1f0f1清0，开辟堆栈空间的return address和old s1都为0xFFFFFFFF）。
- HALT：关机。
- INT <__int64>：执行中断。中断号码为指令参数，r0作为附加参数。所有硬件信息都由INT来完成

## 堆栈结构
```
s1                               s0
|                                |
|free space|return address|old s1|
```
