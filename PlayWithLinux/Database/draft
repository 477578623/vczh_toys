# The previous draft is actually an object-oriented database, not a graph database, so I am going to redesign it.
#
# Concepts:
# 	Collection, Index, View (List, Tree, Partial Ordering, Graph), Collection Variable
# 	Struct, Entity, Query, Cached Query, Function, Function Closure
# 	View Operation (Create Subtree, Subgraph Matching, Path Searching, Strong Connected Components, etc)
# 	Pattern Matching, Multiple Dispatching

################################################
# TYPE

bool, int, float, string

enum Season = Spring | Summer | Autumn | Winter;

struct Point
(
	x : int,
	y : int
);

################################################
# COLLECTION AND INDEX

data AttendExam(s : Student, e : Exam, score : int)
 index	Hash(s),
		Hash(e),
		Unique(e, s), # Hash(e, s), hash index is always default
		Partition(e) Ordered(score) # Ordered(e, score) is illegal because Exam is not sortable
		;

################################################
# ENTITY, INDEX AND VIEW

entity Person
(
	name : string,
	id : string,
) index Hash(name),
		Unique(id)
		;

entity School
(
	students : data(Student)
);

entity Student : Person
(
	school : School
);

entity index 1..n Student.school * School.students;	# school and students are connected, verified and modifiable

================================================

entity Tree
(
	data				: int,
	left				: Tree,
	right				: Tree,
	readonly parent		: Tree,
	readonly children	: data(tree)
) index	Ordered(data)
		;

entity index 1..1 Tree.left > Tree.parent;		# parent is readonly, left is modifiable, verified
entity index 1..1 Tree.right > Tree.parent;		# parent is readonly, right is modifiable, verified
entity index 1..n Tree.parent * Tree.children;	# parent and children are connected, so children is readable

################################################
# COMPLEX ENTITY FIELD TYPE

################################################
# QUERY, CACHED QUERY AND AGGREGATION

enum Gender = Male | Female;

entity Person
(
	name		: string,
	gender		: Gender,
	parents		: data(Person),
	children	: data(Person)
) index	Ordered(name)
		;

entity index n..n Person.parents * Person.children;

# query
query GrandParents(person : Person, grandParent : Person) :-
	person.parents(out parent),
	parent.parents(out grandParent);

# cached query
query GP_Cached(in person : Person, grandParent : Person) :-
	GrandParents(person, out grandParent)
 index	Cached(person)	# Cached likes primary key index, one query can has only one Cached index
		;				# Cached(person) creates Hash(person) if not other index on (person) is used

# ordering
query ExamTop3(out s : Student, in e : Exam, out score : int) :-
	AttendExam(out s, e, out score)
OrderByDesc score(s, e, Top(score, 3));

# group by
query ExamAttendCount(in e: Exam, out count : int) :-
	AttendExam(_, e, _)
GroupBy e(e, count = Count(e));

# partition
query AllExamTop3(out s : Student, out e : Exam, out score : int) :-
	AttendExam(out s, out e, out score)
PartitionBy e(s, e, Top(OrderByDesc(score), 3));

# inner join

# left join

################################################
# FUNCTION

################################################
# CONDITION AND EXCEPTION

################################################
# VIEW AND VIEW OPERATION

################################################
# PATTERN MATCHING, MULTIPLE DISPATCHING

################################################
# NAMESPACE, MODULE AND DATABASE

################################################
# SCHEMA AND SYSTEM COLLECTION
