database Types;

####################################

data List a = List a | Empty

func reverse_ a b =
	switch a (
		Empty : b
		List c d : reverse_ d (List c b)
	)

func reverse a b = reverse_ a Empty

func concat a b = reverse_ (reverse a) b

####################################
# the following code should be imported from Vczh Parser Generator

namespace ast
{
	class Node
	(
	);

	class Type : NOde
	(
	);
	
	class RefType : Type
	(
		name : string
	);
	
	class ApplyType : Type
	(
		function : Type,
		argument : Type
	);
	
	class Expression : Node
	(
	);

	class NumExpr : Expression
	(
		number : int
	);
	
	class RefExpr : Expression
	(
		name : string
	);

	class LambdaExpr : Expression
	(
		argument : string,
		result : Expression
	);
	
	class ApplyExpr : Expression
	(
		function : Expression,
		argument : Expression
	);
	
	class MatchItem : Node
	(
		pattern : Type,
		result : Expression
	);
	
	class MatchExpr : Expression
	(
		expression : Expression,
		items : MatchItem[]
	);
	
	class Declaration : Node
	(
	);
	
	class Argument : Node
	(
		name : string
	);

	class DataItem : Node
	(
		name : string,
		arguments : Type[]
	);
	
	class DataDecl : Declaration
	(
		name : string,
		arguments : Argument[],
		items : DataItem[]
	);
	
	class FuncDecl : Declaration
	(
		name : string,
		arguments : Argument[]
		result : Expression
	);
	
	class Program : Node
	(
		declarations : Declaration[]
	);
}
####################################

namespace symbol
{
	class Type
	(
	);

	class IntType : Type
	(
	);

	# two UnknownType equals iif they are the same instance
	data class UnknownType : Type
	(
		id : int # for printing
	) index AutoIncresed(id);

	class FuncType : Type
	(
		argument : Type,
		result : Type
	);

	class ApplyType : Type
	(
		function : Type,
		argument : Type
	);

	# two LambdaArgumentType equals iif they have the same "belongTo"
	class LambdaArgumentType : Type
	(
		belongTo : LambdaType
	);

	data class LambdaType : Type
	(
		id : int, # for printing
		type : Type
	) index AutoIncresed(id);

	data Types(name : string, type : Type)
		index	Hash(name),
				Unique(name);

	data class Scope
	(
		parent : Scope,
		children : Scope[],
	);
	data index Scope.parent * Scope.children : 1..n;
	data Symbols(scope : Scope, name : string, type : Type, createdBy : Node)
		index	Hash(scope),
				Hash(name),
				Unique(scope, name);
	data AstScopes(scope : Scope, node : ast.Node)
		index	Hash(node),
				Unique(scope, node);
	data ExprTypes(expr : Expression, type : Type)
		index	Hash(expr),
				Unique(expr);
	data Errors(message : string);
}

####################################
# Install a program

using namespace symbol

public func InstallProgram(in program : Program) :-
	Install(program, null);

func install(in node : Node, in parentScope : Scope);

func Install(in program : Program) :-
	let scope = Scope{ parent = parentScope },
	ensure set AstScopes(scope, program)
	for program.declarations(decl)
	(
		Install(decl, scope)
	);

func Install(in decl : DataDecl, in parentScope : Scope) :-
	if not set Types(decl.name, UnknownType{})
		then set Errors($"Duplicated type $(decl.type) found."),
	let scope = Scope{ parent = parentScope },
	ensure set AstScopes(scope, decl),
	for decl.arguments(arg)
	(
		if not set Symbols(scope, arg.name, UnknownType{}, arg)
			then set Errors($"Duplicated function argument $(arg.name) in $(decl.name) found.")
	),
	for decl.items(item)
	(
		Install(item, scope)
	);

func Install(in decl : DeclItem, in parentScope : Scope) :-
	ensure set AstScopes(parentScope, decl),
	if not set Symbols(parentScope.parent, decl.name, UnknownType{}, decl)
		then set Errors($"Duplicated function $(decl.name) found.")
	;

func Install(in decl : FuncDecl, in parentScope : Scope) :-
	let scope = Scope{ parent = parentScope },
	ensure set AstScopes(scope, decl),
	if not set Symbols(scope, decl.name, UnknownType{}, decl)
		then set Errors($"Duplicated function $(decl.name) found."),
	for decl.arguments(arg)
	(
		if not set Symbols(scope, arg.name, UnknownType{}, arg)
			then set Errors($"Duplicated function argument $(arg.name) in $(decl.name) found.")
	),
	Install(decl.result, scope);

func Install(in expr : NumExpr, in parentScope : Scope) :-
	ensure set AstScopes(parentScope, expr),
	ensure set ExprTypes(expr, IntType{});

func Install(in expr : RefExpr, in parentScope : Scope) :-
	ensure set AstScopes(parentScope, expr),
	ensure set ExprTypes(expr, UnknownType{});

func Install(in expr : LambdaExpr, in parentScope : Scope) :-
	let scope = Scope{ parent = parentScope },
	ensure set AstScopes(scope, expr),
	ensure set Symbols(scope, expr.argument, UnknownType{}, decl),
	Install(expr.argument, scope),
	ensure set ExprTypes(expr, UnknownType{});

func Install(in expr : ApplyExpr, in parentScope : Scope) :-
	ensure set AstScopes(parentScope, expr),
	Install(expr.function, parentScope),
	Install(expr.argument, parentScope),
	ensure set ExprTypes(expr, UnknownType{});

func Install(in expr : MatchExpr, in parentScope : Scope) :-
	ensure set AstScopes(parentScope, expr),
	Install(parentScope, expr.pattern)
	for expr.items(item)
	(
		Install(item, parentScope)
	),
	ensure set ExprTypes(expr, UnknownType{});

func Install(in expr : MatchItem, in parentScope : Scope) :-
	let scope = Scope{ parent = parentScope },
	ensure set AstScopes(scope, expr),
	InstallPattern(expr.pattern, scope),
	Install(expr.result, scope);

func InstallPattern(in pattern : Type, in parentScope : Scope);

func InstallPattern(in pattern : RefType, in parentScope : Scope) :-
	if not set Symbols(parentScope, pattern.name, UnknownType{}, pattern)
		then set Errors($"Duplicated pattern $(pattern.name) found."),
	;

func InstallPattern(in pattern : ApplyType, in parentScope : Scope) :-
	InstallPattern(pattern.function, parentScope),
	InstallPattern(pattern.function, parentScope);

####################################
# Build the unification graph

####################################
# Type inference
